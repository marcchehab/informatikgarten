---
title: "01: Kryptografie Intro"
---
## Wieso Kryptografie?

> [!example] Praktischer Einstieg
> 
> Setzten Sie sich in 4er- und 5er-Gruppen zusammen. Sie sind alles Spione eines Geheimdienstes und m√ºssen eine Geheimschrift entwickeln, wie Sie **Nachrichten ver- und entschl√ºsseln** k√∂nnen. Aber Achtung! Ihre Nachrichten k√∂nnen in die falschen H√§nde geraten. Schaffen Sie es eine Methode zu finden, die **die gegnerischen Geheimdienste nicht knacken k√∂nnen**? 
> 
> Sie haben 15 Minuten Zeit f√ºr folgende Aufgaben:
> - Einigen Sie sich auf eine **Methode**
> - Teilen Sie Ihre Gruppe in **zwei Teilgruppen**. Jede Teilgruppe **verschl√ºsselt** eine hochgeheime Nachricht √ºber ein Treffen mit 3 S√§tzen f√ºr die andere Teilgruppe.
> - Die andere Teilgruppe **entschl√ºsselt** die Nachricht, um zu schauen, ob Ihre Methode funktioniert.
> 
> ...doch dann passiert der Super-GAU!
> 
> (Musik f√ºrs [Ambiente](https://open.spotify.com/track/4y8GgkINBu7hH7IX9CBw87?si=16e17ac2221e4b06))

## Kryptografie mit Hilfe von Python

Weite Teile des modernen Internets basieren auf demselben Prinzip: dass Nachrichten geheim √ºbertragen werden k√∂nnen. Wir n√§hern uns hier diesem Thema an und schauen, wie wir mit Python eine eigene Verschl√ºsselungsfunktion schreiben k√∂nnen. Zuerst einigen wir uns doch auf die Begriffe:
- **Klartext**: Die Information, die wir verschl√ºsseln.
- **Geheimtext**: Die verschl√ºsselte Zeichenkette
- **Schl√ºssel**: Was man wissen muss, um den Geheimtext in den Klartext umzuwandeln.

Sie m√ºssen als Basis allerdings wissen, wie Computer Texte speichern.

### ASCII und Unicode
Es wird Sie kaum √ºberraschen, dass Texte in Computern letztlich eine Serie von Bin√§rzahlen sind. Die Semantik ist letztlich einfach eine Tabelle, **die jeder Zahl einen Buchstaben zuordnet**. 

Heute verwenden wir daf√ºr weiterhin die sogenannte ASCII-Tabelle, die in den 1960ern standardisiert wurde. Dieser Zeichensatz wurde f√ºr die √úbertragung so klein wie m√∂glich gehalten, n√§mlich 7 Bit oder 128 Zeichen.

![[index 2024-06-10 11.09.08.excalidraw]]

Beispiel:
- `A` hat den ASCII-Code 65.
- `a` hat den ASCII-Code 97.

ASCII deckt haupts√§chlich die englische Sprache ab und hat somit Einschr√§nkungen f√ºr andere Sprachen und Symbole (z.B. `‚Ç¨ ‚Äî ¬© ‚Ñ¢ ‚àÜ Œ© ‰Ω†Â•Ω –ü—Ä–∏–≤—ñ—Ç üòä üéâ`)

Als Reaktion auf die Beschr√§nkungen von ASCII wurde Unicode entwickelt, um alle Schriftzeichen aller Sprachen darzustellen. Unicode kann √ºber 1 Million Zeichen kodieren, von denen bisher √ºber 143'000 definiert sind. 

Bin√§r nutzt Unicode den Umstand, dass die ASCII-Tabelle nur 7 Bit ben√∂tigt, also dass ein "normales" ASCII-Byte mit 0 beginnen w√ºrde. Unicode sagt nun: Wir signalisieren mit **`1` am Anfang des ersten Byte**, wie viele Bytes wir nutzen, und mit `10` am Anfang der weiteren Bytes, dass sie teil des gleichen Symbols sind.

- **1 Byte** (f√ºr Zeichen von U+0000 bis U+007F):
    - Format: `0xxxxxxx`
    - Beispiel: `A` (U+0041) -> `01000001`
- **2 Bytes** (f√ºr Zeichen von U+0080 bis U+07FF):
    - Format: `110xxxxx 10xxxxxx`
    - Beispiel: `√©` (U+00E9) -> `11000011 10101001`
- **3 Bytes** (f√ºr Zeichen von U+0800 bis U+FFFF):
    - Format: `1110xxxx 10xxxxxx 10xxxxxx`
    - Beispiel: `‰Ω†` (U+4F60) -> `11100100 10111101 10100000`
- **4 Bytes** (f√ºr Zeichen von U+10000 bis U+10FFFF):
    - Format: `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx`
    - Beispiel: `êçà` (U+10348) -> `11110000 10010000 10001101 10001000`

### W√∂rter sind Listen von Unicode-Symbolen in Python

Beim Erstellen einer Verschl√ºsselungsfunktion hilft Ihnen der Umstand, dass man in Python **Zeichenketten wie Listen behandeln** kann. Zudem k√∂nnen Sie mit der **Funktion ord()** den Unicode des Buchstabens auslesen und **chr() macht aus einem Unicode wieder den Buchstaben**.

```turtle
satz = "Hallo üòç"

for buchstabe in satz:
	print(buchstabe, " hat den Code ", ord(buchstabe))

print("Ein Beispiel f√ºr einen Unicode: ", chr(100))
```

### Caesar-Verschl√ºsselung

Die Caesar-Verschl√ºsselung ist eine der einfachsten und bekanntesten Methoden der klassischen Kryptografie. Sie wurde nach Julius Caesar benannt, der diese Methode angeblich verwendet hat, um seine milit√§rischen Nachrichten zu verschl√ºsseln.

Die Caesar-Verschl√ºsselung ist eine sogenannte **monoalphabetische Substitution**. Das bedeutet, dass jeder Buchstabe des Klartextes durch einen anderen Buchstaben des Alphabets ersetzt wird. Der Ersatz erfolgt durch eine feste Anzahl von Stellen, die als Schl√ºssel bezeichnet wird. 
#### Funktionsweise

1. **Alphabetverschiebung**: Jeder Buchstabe im Klartext wird durch den Buchstaben ersetzt, der eine bestimmte Anzahl von Positionen weiter im Alphabet steht.
   - Zum Beispiel: Bei einer Verschiebung um 3 (dem klassischen Schl√ºssel) wird `A` zu `D`, `B` zu `E`, und so weiter.
2. **Modulares Rechnen**: Da das Alphabet zyklisch ist, wird am Ende des Alphabets wieder von vorne begonnen. 
   - Zum Beispiel: `X` wird zu `A`, `Y` wird zu `B`, und `Z` wird zu `C` bei einer Verschiebung um 3.
#### Beispiel

- **Klartext**: "HELLO"
- **Schl√ºssel**: 3
- **Verschl√ºsselter Text**: "KHOOR"

Hierbei wird jeder Buchstabe des Klartextes um drei Positionen im Alphabet verschoben.

#### Vorteile und Nachteile

- **Vorteile**:
  - Einfachheit: Die Caesar-Verschl√ºsselung ist leicht zu verstehen und umzusetzen.
  - Geschwindigkeit: Aufgrund ihrer Einfachheit kann sie sehr schnell angewendet werden.

- **Nachteile**:
  - Schwache Sicherheit: Die Caesar-Verschl√ºsselung ist anf√§llig f√ºr einfache Kryptoanalysen. Mit nur 25 m√∂glichen Verschiebungen (bei einem Alphabet von 26 Buchstaben) kann ein Angreifer alle m√∂glichen Schl√ºssel ausprobieren (Brute-Force-Angriff) oder durch eine H√§ufigkeitsanalyse den Schl√ºssel schnell herausfinden.

### Vigen√®re-Verschl√ºsselung

Die Vigen√®re-Verschl√ºsselung ist eine weiterentwickelte Form der monoalphabetischen Substitution und stellt eine **polyalphabetische Substitution** dar. Sie wurde nach Blaise de Vigen√®re benannt und ist deutlich sicherer als die Caesar-Verschl√ºsselung, da sie mehrere Caesar-Verschiebungen kombiniert.

#### Funktionsweise

1. **Schl√ºsselwort verwenden**: Ein Schl√ºsselwort bestimmt die Verschiebungen f√ºr die einzelnen Buchstaben des Klartextes. Jeder Buchstabe des Schl√ºsselworts gibt an, um wie viele Positionen der entsprechende Buchstabe des Klartextes verschoben wird.
   - Zum Beispiel: Bei dem Schl√ºsselwort "KEY" wird der erste Buchstabe des Klartextes um die Position des Buchstabens "K" (10 Positionen), der zweite um "E" (4 Positionen) und der dritte um "Y" (24 Positionen) verschoben. Dieses Muster wiederholt sich, wenn das Schl√ºsselwort k√ºrzer als der Klartext ist.
2. **Verschiebung berechnen**: Jeder Buchstabe des Klartextes wird basierend auf dem entsprechenden Buchstaben des Schl√ºsselwortes verschoben.
#### Beispiel

- **Klartext**: "HELLO"
- **Schl√ºsselwort**: "KEY"
- **Schl√ºsselwort erweitert**: "KEYKE"
- **Verschl√ºsselter Text**: "RIJVS"

Hierbei wird jeder Buchstabe des Klartextes unterschiedlich verschoben:

- `H` (Shift 10) -> `R`
- `E` (Shift 4) -> `I`
- `L` (Shift 24) -> `J`
- `L` (Shift 10) -> `V`
- `O` (Shift 4) -> `S`

![[crypto-01-klassisch 2024-06-10 12.39.53.excalidraw]]

#### Vorteile und Nachteile

- **Vorteile**:
  - Erh√∂hte Sicherheit: Durch die Verwendung eines Schl√ºsselwortes und die daraus resultierenden variablen Verschiebungen ist die Vigen√®re-Verschl√ºsselung weniger anf√§llig f√ºr einfache Kryptoanalysen.
  - Verschleierung der H√§ufigkeit: H√§ufigkeitsmuster des Klartextes werden verschleiert, was die Analyse erschwert.

- **Nachteile**:
  - Schl√ºsselverwaltung: Die Sicherheit h√§ngt stark von der Geheimhaltung und der Komplexit√§t des Schl√ºsselworts ab.
  - Anf√§lligkeit f√ºr bestimmte Angriffe: Bei sehr langen Texten und kurzen Schl√ºsselw√∂rtern kann die Vigen√®re-Verschl√ºsselung durch bestimmte Kryptoanalysetechniken wie die Kasiski-Untersuchung geknackt werden.

### Scytale-Verschl√ºsselung

Die Scytale-Verschl√ºsselung ist eine der √§ltesten bekannten Verschl√ºsselungsmethoden und wurde im antiken Griechenland verwendet. Sie ist eine Form der **Transpositionsverschl√ºsselung**, bei der die Positionen der Zeichen im Klartext ver√§ndert werden, ohne die Zeichen selbst zu ver√§ndern.

#### Funktionsweise

1. **Scytale-Stab**: Ein Stab oder Zylinder mit einem bestimmten Durchmesser wird verwendet. Die Nachricht wird auf einen Streifen Papier geschrieben, der um den Stab gewickelt wird.
2. **Zeilenweise Lesen**: Nachdem die Nachricht auf den Stab gewickelt wurde, wird sie in Zeilen geschrieben. Der verschl√ºsselte Text wird dann zeilenweise abgelesen.
![[Pasted image 20240610125006.png]]
#### Beispiel

- **Klartext**: "diesisteinegeheimenachricht"
- **Anzahl der Zeilen**: 5 (wird als Anzahl der "Rails" oder Spalten interpretiert)

**Schritt-f√ºr-Schritt-Verfahren**:
1. Schreibe die Nachricht zeilenweise um den Stab:
   ```
   d i e s i
   s t e i n
   e g e h e
   i m e n a
   c h r i c
   h t
   ```

2. Lies die Zeichen spaltenweise ab, um den verschl√ºsselten Text zu erhalten:
   ```
   Verschl√ºsselte Nachricht: "dseich itgmht eeeer sihni ineac"
   ```

#### Vorteile und Nachteile

- **Vorteile**:
  - Einfachheit: Die Scytale-Verschl√ºsselung ist leicht zu verstehen und umzusetzen.
  - Historische Bedeutung: Sie ist eine der √§ltesten bekannten Verschl√ºsselungsmethoden und bietet Einblick in fr√ºhe Kryptografie.

- **Nachteile**:
  - Schwache Sicherheit: Die Scytale-Verschl√ºsselung ist anf√§llig f√ºr einfache Kryptoanalysen, da die Transpositionsmuster leicht erkannt und r√ºckg√§ngig gemacht werden k√∂nnen.
  - Begrenzte Anwendung: In modernen Anwendungen bietet die Scytale-Verschl√ºsselung keinen ausreichenden Schutz.

Die Scytale-Verschl√ºsselung veranschaulicht grundlegende Konzepte der Transpositionsverschl√ºsselung und ist ein historisch bedeutendes Beispiel f√ºr fr√ºhe kryptografische Methoden.

## Python-Funktionen f√ºr klassische Verschl√ºsselungsverfahren

> [!solution]- Eine Caesar-Verschl√ºsselung
> 
> ```python
> def caesar_verschluesselung(text, verschiebung):
>     # Initialisiere den verschl√ºsselten Text als leere Zeichenkette
>     verschluesselter_text = ""
>     
>     # Gehe jeden Buchstaben im Eingabetext durch
>     for char in text:
>         # √úberpr√ºfe, ob der Buchstabe ein Grossbuchstabe ist
>         if char.isupper():
>             # Berechne die neue Position und sorge daf√ºr, dass sie im Bereich von A-Z bleibt
>             neue_position = (ord(char) + verschiebung - 65) % 26 + 65
>             # F√ºge den verschl√ºsselten Buchstaben zum verschl√ºsselten Text hinzu
>             verschluesselter_text += chr(neue_position)
>         # √úberpr√ºfe, ob der Buchstabe ein Kleinbuchstabe ist
>         elif char.islower():
>             # Berechne die neue Position und sorge daf√ºr, dass sie im Bereich von a-z bleibt
>             neue_position = (ord(char) + verschiebung - 97) % 26 + 97
>             # F√ºge den verschl√ºsselten Buchstaben zum verschl√ºsselten Text hinzu
>             verschluesselter_text += chr(neue_position)
>         else:
>             # Wenn es kein Buchstabe ist, f√ºge das Zeichen unver√§ndert hinzu
>             verschluesselter_text += char
>     
>     # Gebe den verschl√ºsselten Text zur√ºck
>     return verschluesselter_text
> 
> # Beispiel zur Verwendung der Funktion
> text = "Hallo liebe G1b! K√∂nnen Sie diesen Text entschl√ºsseln? Liebe Gr√ºsse, Marc Chehab"
> verschiebung = 3
> print(caesar_verschluesselung(text, verschiebung))  # Ausgabe: "Kdoor Zhow"
> ```

